"use strict"

// External deps use normal require
;

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.ProxyServer = undefined;

var _upstream = require('./upstream');

var _route = require('./route');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var http = require('http');
var httpProxy = require('http-proxy');
var Router = require('router');

// Internal deps use ES6 module syntax

var ProxyServer = exports.ProxyServer = (function () {
	function ProxyServer() {
		var _this = this;

		var opts = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

		_classCallCheck(this, ProxyServer);

		// Save the host and port the server was opened on
		this.hostname = opts.hostname || null;
		this.port = opts.port || null;

		// Create router
		this.router = new Router(opts.routerOptions);

		// Create http server
		this.server = http.createServer(function (req, res, next) {
			_this.router(req, res, function () {
				// do after stuff
				console.log('WAT?', req.url);
			});
		});

		// Create the proxy server
		this.proxy = httpProxy.createProxyServer({
			changeOrigin: true
		});
		this.proxy.on('error', function (err) {
			console.error(err);
		});

		// Register upstreams
		this.upstreams = {};
		this.registerUpstreams(opts.upstreams);

		// Register the routes from the config
		this.routes = [];
		this.registerRoutes(opts.routes);
	}

	/**
  * Start listening on a port and hostname
  */

	_createClass(ProxyServer, [{
		key: 'listen',
		value: function listen() {
			var port = arguments.length <= 0 || arguments[0] === undefined ? this.port : arguments[0];

			var _this2 = this;

			var hostname = arguments.length <= 1 || arguments[1] === undefined ? this.hostname : arguments[1];
			var ready = arguments.length <= 2 || arguments[2] === undefined ? function () {} : arguments[2];

			this.server.listen(port, hostname, function (err) {
				_this2.hostname = hostname;
				_this2.port = _this2.server.address().port;
				ready(err);
			});
		}

		/**
   * Registers the upstream servers
   *
   */

	}, {
		key: 'registerUpstreams',
		value: function registerUpstreams(upstreams) {
			var _this3 = this;

			Object.keys(upstreams).forEach(function (k) {
				upstreams[k].proxy = _this3.proxy;
				_this3.upstreams[k] = new _upstream.Upstream(k, upstreams[k]);
			});
		}

		/**
   * Registers the known routes with the router
   *
   */

	}, {
		key: 'registerRoutes',
		value: function registerRoutes(routes) {
			var _this4 = this;

			// For each route, register handler method
			routes.forEach(function (r) {
				// If an upstream is specified, replace it
				if (r.upstream && _this4.upstreams[r.upstream]) {
					r.upstream = _this4.upstreams[r.upstream];
				}

				// Create route object
				var route = new _route.Route(r);
				_this4.routes.push(route);

				// Register route handler
				route.methods.forEach(function (method) {
					_this4.router[method](route.path, function (req, res, next) {
						// Check for matching parameters that are not checked for
						// in the path router, like hostname, next it doesnt match
						if (!route.matches(req)) {
							return next();
						}

						route.handle(req, res, next);
					});
				});
			});
		}
	}]);

	return ProxyServer;
})();