'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _class, _temp; /*
                    * Copyright 2015-present Boundless Spatial Inc., http://boundlessgeo.com
                    * Licensed under the Apache License, Version 2.0 (the "License").
                    * You may not use this file except in compliance with the License.
                    * You may obtain a copy of the License at
                    * http://www.apache.org/licenses/LICENSE-2.0
                    * Unless required by applicable law or agreed to in writing, software
                    * distributed under the License is distributed on an "AS IS" BASIS,
                    * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                    * See the License for the specific language governing permissions and limitations under the License.
                    */

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _openlayers = require('openlayers');

var _openlayers2 = _interopRequireDefault(_openlayers);

var _LayerStore = require('../stores/LayerStore');

var _LayerStore2 = _interopRequireDefault(_LayerStore);

var _Button = require('./Button');

var _Button2 = _interopRequireDefault(_Button);

var _classnames = require('classnames');

var _classnames2 = _interopRequireDefault(_classnames);

var _Dialog = require('material-ui/Dialog');

var _Dialog2 = _interopRequireDefault(_Dialog);

var _SelectField = require('material-ui/SelectField');

var _SelectField2 = _interopRequireDefault(_SelectField);

var _IconMenu = require('material-ui/IconMenu');

var _IconMenu2 = _interopRequireDefault(_IconMenu);

var _MenuItem = require('material-ui/MenuItem');

var _MenuItem2 = _interopRequireDefault(_MenuItem);

var _jspdf = require('jspdf');

var _jspdf2 = _interopRequireDefault(_jspdf);

var _LinearProgress = require('material-ui/LinearProgress');

var _LinearProgress2 = _interopRequireDefault(_LinearProgress);

var _Snackbar = require('material-ui/Snackbar');

var _Snackbar2 = _interopRequireDefault(_Snackbar);

var _AppDispatcher = require('../dispatchers/AppDispatcher');

var _AppDispatcher2 = _interopRequireDefault(_AppDispatcher);

var _toolutil = require('../toolutil');

var _toolutil2 = _interopRequireDefault(_toolutil);

var _TextField = require('material-ui/TextField');

var _TextField2 = _interopRequireDefault(_TextField);

var _print2 = require('material-ui/svg-icons/action/print');

var _print3 = _interopRequireDefault(_print2);

var _reactIntl = require('react-intl');

var _getMuiTheme = require('material-ui/styles/getMuiTheme');

var _getMuiTheme2 = _interopRequireDefault(_getMuiTheme);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var messages = (0, _reactIntl.defineMessages)({
  closebutton: {
    'id': 'qgisprint.closebuttontext',
    'defaultMessage': 'Close'
  },
  modaltitle: {
    'id': 'qgisprint.modaltitle',
    'defaultMessage': 'Print map'
  },
  resolutionlabel: {
    'id': 'qgisprint.resolutionlabel',
    'defaultMessage': 'Resolution'
  },
  printbuttontitle: {
    'id': 'qgisprint.printbuttontitle',
    'defaultMessage': 'Print map'
  },
  printbuttontext: {
    'id': 'qgisprint.printbuttontext',
    'defaultMessage': 'Print'
  },
  printmenutext: {
    'id': 'qgisprint.printmenutext',
    'defaultMessage': 'Print'
  },
  error: {
    'id': 'qgisprint.error',
    'defaultMessage': 'Error while generating PDF, details: {details}'
  }
});

var MM_PER_INCH = 25.4;
var MM_PER_POINT = 0.352777778;

/**
 * A print component which is dependent on artefacts generated by QGIS Web Application Builder.
 *
 * ```javascript
 * var printLayouts = [{
 *   name: 'Layout 1',
 *   thumbnail: 'layout1_thumbnail.png',
 *   width: 420.0,
 *   elements: [{
 *     name: 'Title',
 *     height: 40.825440467359044,
 *     width: 51.98353115727002,
 *     y: 39.25222551928783,
 *     x: 221.77507418397624,
 *     font: 'Helvetica',
 *     type: 'label',
 *     id: '24160ce7-34a3-4f25-a077-8910e4889681',
 *     size: 18
 *   }, {
 *     height: 167.0,
 *     width: 171.0,
 *     grid: {
 *       intervalX: 0.0,
 *       intervalY: 0.0,
 *       annotationEnabled: false,
 *       crs: ''
 *     },
 *     y: 19.0,
 *     x: 16.0,
 *     type: 'map',
 *     id: '3d532cb9-0eca-4e50-9f0a-ce29b1c7f5a6'
 *   }],
 *   height: 297.0
 * }];
 * ```
 *
 * ```xml
 * <QGISPrint map={map} layouts={printLayouts} />
 * ```
 */
var QGISPrint = (_temp = _class = function (_React$PureComponent) {
  _inherits(QGISPrint, _React$PureComponent);

  function QGISPrint(props, context) {
    _classCallCheck(this, QGISPrint);

    var _this = _possibleConstructorReturn(this, (QGISPrint.__proto__ || Object.getPrototypeOf(QGISPrint)).call(this, props));

    _this._dispatchToken = _toolutil2.default.register(_this);
    _this._muiTheme = context.muiTheme || (0, _getMuiTheme2.default)();
    _LayerStore2.default.bindMap(_this.props.map);
    _this.state = {
      disabled: false,
      layout: null,
      layoutName: null,
      loading: false,
      error: false,
      open: false,
      errorOpen: false,
      resolution: null
    };
    return _this;
  }

  _createClass(QGISPrint, [{
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      _AppDispatcher2.default.unregister(this._dispatchToken);
    }
  }, {
    key: 'getChildContext',
    value: function getChildContext() {
      return { muiTheme: this._muiTheme };
    }
  }, {
    key: 'close',
    value: function close() {
      this.setState({
        open: false
      });
    }
  }, {
    key: '_onClick',
    value: function _onClick(layout, event) {
      this.setState({ open: true, layoutName: layout.name, layout: layout });
    }
  }, {
    key: '_onPrintButtonClick',
    value: function _onPrintButtonClick() {
      var layout = this.props.layouts[0];
      this.setState({ open: true, layoutName: layout.name, layout: layout });
    }
  }, {
    key: '_elementLoaded',
    value: function _elementLoaded() {
      this._elementsLoaded++;
      if (this._elementsLoaded === this.state.layout.elements.length) {
        this._pdf.save('map.pdf');
        this.setState({ loading: false });
      }
    }
  }, {
    key: '_getTileLayers',
    value: function _getTileLayers() {
      var state = _LayerStore2.default.getState();
      var tileLayers = [];
      for (var i = 0, ii = state.flatLayers.length; i < ii; ++i) {
        var layer = state.flatLayers[i];
        if (layer instanceof _openlayers2.default.layer.Tile && layer.getVisible()) {
          tileLayers.push(layer);
        }
      }
      return tileLayers;
    }
  }, {
    key: '_tileLayerLoaded',
    value: function _tileLayerLoaded() {
      this._tiledLayersLoaded++;
      if (this._tiledLayersLoaded === this._tileLayers.length) {
        var me = this;
        global.setTimeout(function () {
          me._paintMapInPdf();
        }, 1000);
      }
    }
  }, {
    key: '_paintMapInPdf',
    value: function _paintMapInPdf() {
      var data, error;
      try {
        data = this._canvas.toDataURL('image/jpeg');
      } catch (e) {
        error = true;
        this.setState({ loading: false, errorOpen: true, error: true, msg: e });
      }
      var map = this.props.map;
      if (error !== true) {
        var pdf = this._pdf;
        var mapElement = this._mapElement;
        pdf.rect(mapElement.x, mapElement.y, mapElement.width, mapElement.height);
        pdf.addImage(data, 'jpeg', mapElement.x, mapElement.y, mapElement.width, mapElement.height);
      }
      map.setSize(this._origSize);
      map.getView().fit(this._origExtent, this._origSize, { constrainResolution: false });
      map.renderSync();
      this._elementLoaded();
    }
  }, {
    key: '_onResolutionChange',
    value: function _onResolutionChange(evt, idx, value) {
      this.setState({ resolution: value });
    }
  }, {
    key: '_loadStart',
    value: function _loadStart(evt) {
      var idx = this._sources.indexOf(evt.target);
      this._loading[idx]++;
    }
  }, {
    key: '_loadEndError',
    value: function _loadEndError(evt) {
      var idx = this._sources.indexOf(evt.target);
      ++this._loaded[idx];
      if (this._loading[idx] === this._loaded[idx]) {
        this._tileLayerLoaded();
        this._removeLoadListeners(idx);
      }
    }
  }, {
    key: '_attachLoadListeners',
    value: function _attachLoadListeners(idx) {
      this._sources[idx] = this._tileLayers[idx].getSource();
      this._loading[idx] = 0;
      this._loaded[idx] = 0;
      var source = this._sources[idx];
      source.on('tileloadstart', this._loadStart, this);
      source.on('tileloadend', this._loadEndError, this);
      source.on('tileloaderror', this._loadEndError, this);
      var me = this;
      global.setTimeout(function () {
        if (me._loading[idx] === me._loaded[idx]) {
          me._tileLayerLoaded();
          me._removeLoadListeners(idx);
        }
      }, 1000);
    }
  }, {
    key: '_removeLoadListeners',
    value: function _removeLoadListeners(idx) {
      var source = this._sources[idx];
      source.un('tileloadstart', this._loadStart, this);
      source.un('tileloadend', this._loadEndError, this);
      source.un('tileloaderror', this._loadEndError, this);
    }
  }, {
    key: '_addImage',
    value: function _addImage(el, resolution) {
      var type = el.type;
      this._images[el.id] = new Image();
      this._images[el.id].crossOrigin = 'anonymous';
      var me = this;
      this._images[el.id].addEventListener('error', function () {
        me._elementLoaded();
      });
      this._images[el.id].addEventListener('load', function () {
        me._pdf.addImage(me._images[el.id], 'png', el.x, el.y, el.width, el.height);
        me._elementLoaded();
      });
      this._images[el.id].src = type === 'picture' ? this.props.thumbnailPath + el.file : this.props.thumbnailPath + this._layoutSafeName + '_' + el.id + '_' + resolution + '.png';
    }
  }, {
    key: '_createMap',
    value: function _createMap(labels) {
      var map = this.props.map;
      var resolution = this.state.resolution;
      if (resolution === null) {
        return;
      }
      var layout = this.state.layout;
      this._layoutSafeName = layout.name.replace(/[^a-z0-9]/gi, '').toLowerCase();
      var elements = layout.elements;
      var orientation = layout.width > layout.height ? 'landscape' : 'portrait';
      this._pdf = new _jspdf2.default(orientation, 'mm', [layout.width, layout.height]);
      this._images = [];
      this._elementsLoaded = 0;
      var size = map.getSize();
      var extent = map.getView().calculateExtent(size);
      this._tileLayers = this._getTileLayers();
      this._tiledLayersLoaded = 0;
      var preCompose = function preCompose(event) {
        var ctx = event.context;
        ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
        ctx.fillStyle = '#FFFFFF';
        ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);
      };

      var postCompose = function postCompose(event) {
        this._canvas = event.context.canvas;
        this._sources = [];
        this._loaded = [];
        this._loading = [];
        for (var j = 0, jj = this._tileLayers.length; j < jj; j++) {
          this._attachLoadListeners(j);
        }
      };
      for (var i = 0; i < elements.length; i++) {
        var element = elements[i];
        if (element.type === 'label') {
          this._pdf.setFontSize(element.size);
          this._pdf.text(element.x, element.y + element.size * MM_PER_POINT, labels[element.name]);
          this._elementLoaded();
        } else if (element.type === 'map') {
          this._mapElement = element;
          var width = Math.round(element.width * resolution / MM_PER_INCH);
          var height = Math.round(element.height * resolution / MM_PER_INCH);
          map.once('precompose', preCompose, this);
          map.once('postcompose', postCompose, this);
          this._origSize = map.getSize();
          this._origExtent = map.getView().calculateExtent(this._origSize);
          map.setSize([width, height]);
          map.getView().fit(extent, map.getSize(), { constrainResolution: false });
          map.renderSync();
          if (this._tileLayers.length === 0) {
            this._paintMapInPdf();
          }
        } else if (element.type === 'picture' || element.type === 'shape' || element.type === 'arrow' || element.type === 'legend' || element.type === 'scalebar') {
          this._addImage(element, resolution);
        } else {
          this._elementLoaded();
        }
      }
    }
  }, {
    key: '_print',
    value: function _print() {
      this.setState({
        loading: true
      });
      var elements = this.state.layout.elements;
      var labels = {};
      for (var i = 0, ii = elements.length; i < ii; i++) {
        if (elements[i].type === 'label') {
          var name = elements[i].name;
          labels[name] = this.refs[name].getValue();
        }
      }
      this._createMap(labels);
    }
  }, {
    key: '_handleRequestClose',
    value: function _handleRequestClose() {
      this.setState({
        errorOpen: false
      });
    }
  }, {
    key: 'disable',
    value: function disable() {
      this.setState({ disabled: true });
    }
  }, {
    key: 'enable',
    value: function enable() {
      this.setState({ disabled: false });
    }
  }, {
    key: 'render',
    value: function render() {
      var formatMessage = this.props.intl.formatMessage;

      var listitems = this.props.layouts.map(function (lyt, idx) {
        var thumbnail;
        if (lyt.thumbnail) {
          thumbnail = _react2.default.createElement('img', { style: { maxWidth: 130 }, src: this.props.thumbnailPath + lyt.thumbnail });
        }
        return _react2.default.createElement(
          _MenuItem2.default,
          { onTouchTap: this._onClick.bind(this, lyt), key: idx, value: lyt.name, primaryText: lyt.name },
          _react2.default.createElement(
            'div',
            null,
            thumbnail
          )
        );
      }, this);
      var dialog,
          layout = this.state.layout;
      if (layout !== null) {
        var elements;
        for (var i = 0, ii = layout.elements.length; i < ii; ++i) {
          var element = layout.elements[i];
          if (element.type === 'label') {
            if (elements === undefined) {
              elements = [];
            }
            elements.push(_react2.default.createElement(_TextField2.default, { floatingLabelText: element.name, key: element.name, ref: element.name }));
          }
        }
        var selectOptions = this.props.resolutions.map(function (resolution) {
          return _react2.default.createElement(_MenuItem2.default, { key: resolution, value: resolution, primaryText: resolution + ' dpi' });
        });
        var loading, error;
        if (this.state.error) {
          error = _react2.default.createElement(_Snackbar2.default, {
            open: this.state.errorOpen,
            style: { transitionProperty: 'none' },
            message: formatMessage(messages.error, { details: this.state.msg }),
            autoHideDuration: 2000,
            onRequestClose: this._handleRequestClose.bind(this)
          });
        }
        if (this.state.loading === true) {
          loading = _react2.default.createElement(_LinearProgress2.default, { mode: 'indeterminate' });
        }
        var actions = [_react2.default.createElement(_Button2.default, { buttonType: 'Flat', label: formatMessage(messages.closebutton), onTouchTap: this.close.bind(this) }), _react2.default.createElement(_Button2.default, { buttonType: 'Flat', label: formatMessage(messages.printbuttontext), onTouchTap: this._print.bind(this) })];
        dialog = _react2.default.createElement(
          _Dialog2.default,
          { actions: actions, title: formatMessage(messages.modaltitle), modal: true, open: this.state.open, onRequestClose: this.close.bind(this) },
          elements,
          _react2.default.createElement('br', null),
          _react2.default.createElement(
            _SelectField2.default,
            { floatingLabelText: formatMessage(messages.resolutionlabel), value: this.state.resolution, onChange: this._onResolutionChange.bind(this) },
            selectOptions
          ),
          loading,
          error
        );
      }
      if (this.props.menu === false) {
        return _react2.default.createElement(
          'span',
          { style: this.props.style, className: (0, _classnames2.default)('sdk-component qgis-print', this.props.className) },
          _react2.default.createElement(
            _Button2.default,
            { key: 'qgis-print btn', disabled: this.state.disabled, onTouchTap: this._onPrintButtonClick.bind(this), tooltip: formatMessage(messages.printbuttontitle), mini: true, buttonType: 'Action' },
            _react2.default.createElement(_print3.default, null)
          ),
          dialog
        );
      } else {
        return _react2.default.createElement(
          'span',
          { style: this.props.style, className: (0, _classnames2.default)('sdk-component qgis-print', this.props.className) },
          _react2.default.createElement(
            _IconMenu2.default,
            { key: 'qgis-print menu', menuStyle: { width: 150 }, anchorOrigin: { horizontal: 'right', vertical: 'bottom' }, targetOrigin: { horizontal: 'right', vertical: 'top' }, iconButtonElement: _react2.default.createElement(_Button2.default, { buttonType: 'Icon', iconClassName: 'headerIcons ms ms-printer', disabled: this.state.disabled, tooltip: formatMessage(messages.printmenutext) }), value: this.state.layoutName },
            listitems
          ),
          dialog
        );
      }
    }
  }]);

  return QGISPrint;
}(_react2.default.PureComponent), _class.propTypes = {
  /**
   * The ol3 map to use for printing.
   */
  map: _react2.default.PropTypes.instanceOf(_openlayers2.default.Map).isRequired,
  /**
   * An array of print layouts. Each layout is an object with keys such as: name (string, required),
   * thumbnail (string), width (number, required), height (number, required) and an array of elements.
   * Elements are objects with keys such as name (string, optional), type (enum('map', 'label', legend'), optional),
   * height (number, required), width (number, required), x (number, required), y (number, required), font (string),
   * id (string, required), size (number), grid (object with intervalX, intervalY, annotationEnabled and crs keys).
   */
  layouts: _react2.default.PropTypes.arrayOf(_react2.default.PropTypes.shape({
    name: _react2.default.PropTypes.string.isRequired,
    thumbnail: _react2.default.PropTypes.string,
    width: _react2.default.PropTypes.number.isRequired,
    elements: _react2.default.PropTypes.arrayOf(_react2.default.PropTypes.shape({
      name: _react2.default.PropTypes.string,
      type: _react2.default.PropTypes.oneOf(['map', 'label', 'legend']),
      height: _react2.default.PropTypes.number.isRequired,
      width: _react2.default.PropTypes.number.isRequired,
      x: _react2.default.PropTypes.number.isRequired,
      y: _react2.default.PropTypes.number.isRequired,
      font: _react2.default.PropTypes.string,
      id: _react2.default.PropTypes.string.isRequired,
      size: _react2.default.PropTypes.number,
      grid: _react2.default.PropTypes.shape({
        intervalX: _react2.default.PropTypes.number.isRequired,
        intervalY: _react2.default.PropTypes.number.isRequired,
        annotationEnabled: _react2.default.PropTypes.bool.isRequired,
        crs: _react2.default.PropTypes.string.isRequired
      })
    })).isRequired,
    height: _react2.default.PropTypes.number.isRequired
  })).isRequired,
  /**
   * A list of resolutions from which the user can choose from. Please note that artefacts for all resolutions need to get pre-generated by QGIS.
   */
  resolutions: _react2.default.PropTypes.array,
  /**
   * The relative path where thumbnails of the print layouts can be found. Thumbnails are also generated by QGIS.
   */
  thumbnailPath: _react2.default.PropTypes.string,
  /**
   * Css class name to apply on the root element of this component.
   */
  className: _react2.default.PropTypes.string,
  /**
   * Style config.
   */
  style: _react2.default.PropTypes.object,
  /**
   * Should we display as a menu? If not, we display as a button but there can only be 1 print layout then.
   */
  menu: _react2.default.PropTypes.bool,
  /**
   * @ignore
   */
  intl: _reactIntl.intlShape.isRequired
}, _class.contextTypes = {
  muiTheme: _react2.default.PropTypes.object
}, _class.childContextTypes = {
  muiTheme: _react2.default.PropTypes.object.isRequired
}, _class.defaultProps = {
  menu: true,
  thumbnailPath: '../../resources/print/',
  resolutions: [72, 150]
}, _temp);
exports.default = (0, _reactIntl.injectIntl)(QGISPrint);