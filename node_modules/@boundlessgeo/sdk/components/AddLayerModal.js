'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _class, _temp; /*
                    * Copyright 2015-present Boundless Spatial Inc., http://boundlessgeo.com
                    * Licensed under the Apache License, Version 2.0 (the "License").
                    * You may not use this file except in compliance with the License.
                    * You may obtain a copy of the License at
                    * http://www.apache.org/licenses/LICENSE-2.0
                    * Unless required by applicable law or agreed to in writing, software
                    * distributed under the License is distributed on an "AS IS" BASIS,
                    * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                    * See the License for the specific language governing permissions and limitations under the License.
                    */

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _reactDropzone = require('react-dropzone');

var _reactDropzone2 = _interopRequireDefault(_reactDropzone);

var _util = require('../util');

var _util2 = _interopRequireDefault(_util);

var _openlayers = require('openlayers');

var _openlayers2 = _interopRequireDefault(_openlayers);

var _Snackbar = require('material-ui/Snackbar');

var _Snackbar2 = _interopRequireDefault(_Snackbar);

var _reactIntl = require('react-intl');

var _TextField = require('material-ui/TextField');

var _TextField2 = _interopRequireDefault(_TextField);

var _IconButton = require('material-ui/IconButton');

var _IconButton2 = _interopRequireDefault(_IconButton);

var _Button = require('./Button');

var _Button2 = _interopRequireDefault(_Button);

var _MenuItem = require('material-ui/MenuItem');

var _MenuItem2 = _interopRequireDefault(_MenuItem);

var _Dialog = require('./Dialog');

var _Dialog2 = _interopRequireDefault(_Dialog);

var _SelectField = require('material-ui/SelectField');

var _SelectField2 = _interopRequireDefault(_SelectField);

var _WMSService = require('../services/WMSService');

var _WMSService2 = _interopRequireDefault(_WMSService);

var _WFSService = require('../services/WFSService');

var _WFSService2 = _interopRequireDefault(_WFSService);

var _ArcGISRestService = require('../services/ArcGISRestService');

var _ArcGISRestService2 = _interopRequireDefault(_ArcGISRestService);

var _WMTSService = require('../services/WMTSService');

var _WMTSService2 = _interopRequireDefault(_WMTSService);

var _FontIcon = require('material-ui/FontIcon');

var _FontIcon2 = _interopRequireDefault(_FontIcon);

var _CircularProgress = require('material-ui/CircularProgress');

var _CircularProgress2 = _interopRequireDefault(_CircularProgress);

var _getMuiTheme = require('material-ui/styles/getMuiTheme');

var _getMuiTheme2 = _interopRequireDefault(_getMuiTheme);

var _FillEditor = require('./FillEditor');

var _FillEditor2 = _interopRequireDefault(_FillEditor);

var _StrokeEditor = require('./StrokeEditor');

var _StrokeEditor2 = _interopRequireDefault(_StrokeEditor);

var _FeatureStore = require('../stores/FeatureStore');

var _FeatureStore2 = _interopRequireDefault(_FeatureStore);

require('./AddLayerModal.css');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var newOption = 'NEW';
var uploadOption = 'UPLOAD';
var createOption = 'CREATE';
var ID_PREFIX = 'sdk-addlayer-';

var messages = (0, _reactIntl.defineMessages)({
  servertypelabel: {
    'id': 'addlayermodal.servertypelabel',
    'defaultMessage': 'Type'
  },
  createtitlehinttext: {
    'id': 'addlayermodal.createtitlehinttext',
    'defaultMessage': 'Enter layer title'
  },
  createtitlelabeltext: {
    'id': 'addlayermodal.createtitlelabeltext',
    'defaultMessage': 'Layer title'
  },
  attributeslabel: {
    'id': 'addlayermodal.attributeslabel',
    'defaultMessage': 'Attributes (comma-separated names)'
  },
  attributeshint: {
    'id': 'addlayermodal.attributeshint',
    'defaultMessage': 'Use comma-separated names'
  },
  selectlayercombo: {
    'id': 'addlayermodal.selectlayercombo',
    'defaultMessage': 'Select layer'
  },
  sourcecombo: {
    'id': 'addlayermodal.sourcecombo',
    'defaultMessage': 'Select layer source'
  },
  newservername: {
    'id': 'addlayermodal.newservername',
    'defaultMessage': 'Name'
  },
  newservernamehint: {
    'id': 'addlayermodal.newservernamehint',
    'defaultMessage': 'Enter server name'
  },
  newserverurl: {
    'id': 'addlayermodal.newserverurl',
    'defaultMessage': 'URL'
  },
  newserverurlhint: {
    'id': 'addlayermodal.newserverurlhint',
    'defaultMessage': 'Enter server URL'
  },
  newservermodaltitle: {
    'id': 'addlayermodal.newservermodaltitle',
    'defaultMessage': 'Add Server'
  },
  addserverbutton: {
    'id': 'addlayermodal.addserverbutton',
    'defaultMessage': 'Add'
  },
  refresh: {
    'id': 'addlayermodal.refresh',
    'defaultMessage': 'Refresh Layers'
  },
  title: {
    'id': 'addlayermodal.title',
    'defaultMessage': 'New Layer'
  },
  nolayertitle: {
    'id': 'addlayermodal.nolayertitle',
    'defaultMessage': 'No Title'
  },
  errormsg: {
    'id': 'addlayermodal.errormsg',
    'defaultMessage': 'Error. {msg}'
  },
  corserror: {
    'id': 'addlayermodal.corserror',
    'defaultMessage': 'Could not connect to the server. Please verify that the server is online and/or CORS is enabled.'
  },
  inputfieldlabel: {
    'id': 'addlayermodal.inputfieldlabel',
    'defaultMessage': '{serviceType} URL'
  },
  connectbutton: {
    'id': 'addlayermodal.connectbutton',
    'defaultMessage': 'Connect'
  },
  addbutton: {
    'id': 'addlayermodal.addbutton',
    'defaultMessage': 'Add'
  },
  closebutton: {
    'id': 'addlayermodal.closebutton',
    'defaultMessage': 'Cancel'
  },
  addserveroption: {
    'id': 'addlayermodal.addserveroption',
    'defaultMessage': 'Add New Server'
  },
  uploadoption: {
    'id': 'addlayermodal.uploadoption',
    'defaultMessage': 'Upload Local File'
  },
  createlayeroption: {
    'id': 'addlayermodal.createlayeroption',
    'defaultMessage': 'Create New Layer'
  },
  uploadhinttext: {
    'id': 'addlayermodal.uploadhinttext',
    'defaultMessage': 'Select location'
  },
  uploadlabeltext: {
    'id': 'addlayermodal.uploadlabeltext',
    'defaultMessage': 'Filename'
  },
  uploadicontooltip: {
    'id': 'addlayermodal.uploadicontooltip',
    'defaultMessage': 'Upload file'
  },
  pointgeomtype: {
    'id': 'addlayermodal.pointgeomtype',
    'defaultMessage': 'Point'
  },
  linegeomtype: {
    'id': 'addlayermodal.linegeomtype',
    'defaultMessage': 'LineString'
  },
  polygeomtype: {
    'id': 'addlayermodal.polygeomtype',
    'defaultMessage': 'Polygon'
  },
  geometrytypelabel: {
    'id': 'addlayermodal.geometrytypelabel',
    'defaultMessage': 'Geometry type'
  },
  uploadunsupported: {
    'id': 'addlayermodal.uploadunsupported',
    'defaultMessage': 'Unsupported format for upload. Only KML, GPX and GeoJSON are supported.'
  },
  uploadunsupportedprojection: {
    'id': 'addlayermodal.uploadunsupportedprojection',
    'defaultMessage': 'Unsupported projection'
  }
});

/**
 * Modal window to add layers from a WMS, WFS, WMTS or ArcGIS REST service.
 *
 * ```xml
 * <AddLayerModal map={map} allowUserInput={true} sources={[{url: '/geoserver/wms', type: 'WMS', title: 'Local GeoServer'}]} />
 * ```
 *
 * ![Add Layer Modal](../AddLayerModal.png)
 */
var AddLayerModal = (_temp = _class = function (_React$PureComponent) {
  _inherits(AddLayerModal, _React$PureComponent);

  function AddLayerModal(props, context) {
    _classCallCheck(this, AddLayerModal);

    var _this = _possibleConstructorReturn(this, (AddLayerModal.__proto__ || Object.getPrototypeOf(AddLayerModal)).call(this, props));

    _this._counter = 0;
    _this._proxy = context.proxy;
    _this._requestHeaders = context.requestHeaders;
    _this._muiTheme = context.muiTheme || (0, _getMuiTheme2.default)();
    _this.state = {
      loading: false,
      fileName: '',
      attributes: '',
      newUrl: '',
      newName: '',
      createTitle: '',
      sources: _this.props.sources ? _this.props.sources.slice() : [],
      newType: AddLayerModal.addNewTypes[0],
      showNew: false,
      showUpload: false,
      source: null,
      error: false,
      errorOpen: false,
      layerInfo: null
    };
    return _this;
  }

  _createClass(AddLayerModal, [{
    key: 'getChildContext',
    value: function getChildContext() {
      return { muiTheme: this._muiTheme };
    }
  }, {
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps(props) {
      this.setState({
        fileName: '',
        loading: false,
        source: null,
        layer: null,
        layerInfo: null,
        showNew: false,
        showUpload: false,
        newUrl: '',
        newName: ''
      });
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      if (this._request) {
        this._request.abort();
      }
    }
  }, {
    key: '_getCaps',
    value: function _getCaps(onFailure) {
      this.setState({ loading: true, layerInfo: null });
      var source = this.state.sources[this.state.source];
      var url = source.url;
      var service = AddLayerModal.services[source.type];
      var me = this;
      var formatMessage = this.props.intl.formatMessage;

      var failureCb = function failureCb(xmlhttp) {
        delete me._request;
        if (!xmlhttp || xmlhttp.status === 0) {
          me._setError(formatMessage(messages.corserror));
        } else {
          me._setError(xmlhttp.status + ' ' + xmlhttp.statusText);
        }
        if (onFailure) {
          onFailure();
        }
      };
      var successCb = function successCb(layerInfo, onlineResource) {
        delete me._request;
        source.getMapUrl = onlineResource;
        me.setState({ loading: false, layerInfo: layerInfo });
      };
      me._request = service.getCapabilities(url, successCb, failureCb, this._proxy, this._requestHeaders);
    }
  }, {
    key: '_setError',
    value: function _setError(msg) {
      this.setState({
        loading: false,
        errorOpen: true,
        error: true,
        layerInfo: null,
        msg: msg
      });
    }
  }, {
    key: '_getLayerTitle',
    value: function _getLayerTitle(layer) {
      var formatMessage = this.props.intl.formatMessage;

      if (layer.Title === '') {
        return { empty: true, title: formatMessage(messages.nolayertitle) };
      } else {
        return { empty: false, title: layer.Title };
      }
    }
  }, {
    key: '_onLayerClick',
    value: function _onLayerClick(layer) {
      var map = this.props.map;
      var titleObj = this._getLayerTitle(layer);
      var source = this.state.sources[this.state.source];
      var url = source.getMapUrl || source.url;
      var service = AddLayerModal.services[source.type];
      var olLayer = service.createLayer(layer, url, titleObj, map.getView().getProjection(), this._proxy);
      if (olLayer.get('type') === 'base') {
        var foundGroup = false;
        map.getLayers().forEach(function (lyr) {
          if (foundGroup === false && lyr.get('type') === 'base-group') {
            foundGroup = true;
            lyr.getLayers().forEach(function (child) {
              child.setVisible(false);
            });
            lyr.getLayers().push(olLayer);
          }
        });
        if (foundGroup === false) {
          map.addLayer(olLayer);
        }
      } else {
        map.addLayer(olLayer);
      }
      return olLayer;
    }
  }, {
    key: '_getLayersMarkup',
    value: function _getLayersMarkup(layer, menuItems) {
      if (layer.Layer) {
        layer.Layer.map(function (child) {
          this._getLayersMarkup(child, menuItems);
        }, this);
      }
      var layerTitle = this._getLayerTitle(layer);
      var primaryText;
      if (layerTitle.empty) {
        primaryText = _react2.default.createElement(
          'div',
          { className: 'layer-title-empty' },
          layerTitle.title
        );
      } else {
        primaryText = layerTitle.title;
      }
      var search = [layer.Title];
      if (layer.Abstract !== undefined) {
        search.push(layer.Abstract);
      }
      if (layer.KeywordList) {
        search = search.concat(layer.KeywordList);
      }
      if (layer.Name) {
        menuItems.push(_react2.default.createElement(_MenuItem2.default, { key: layer.Name, value: layer, primaryText: primaryText }));
      }
    }
  }, {
    key: 'close',
    value: function close() {
      this.props.onRequestClose();
    }
  }, {
    key: '_createLayer',
    value: function _createLayer() {
      var layerName = this.state.createTitle;
      var geometryType = this.state.geometryType;
      var attributes = this.state.attributes;
      if (layerName !== '') {
        var fill = this.state.fillColor ? new _openlayers2.default.style.Fill({ color: _util2.default.transformColor(this.state.fillColor) }) : undefined;
        var stroke = this.state.strokeColor ? new _openlayers2.default.style.Stroke({ color: _util2.default.transformColor(this.state.strokeColor), width: this.state.strokeWidth }) : undefined;
        var style = new _openlayers2.default.style.Style({
          fill: fill,
          stroke: stroke,
          image: fill || stroke ? new _openlayers2.default.style.Circle({ stroke: stroke, fill: fill, radius: 7 }) : undefined
        });
        var layer = new _openlayers2.default.layer.Vector({
          title: layerName,
          id: this._generateId(),
          geometryType: geometryType,
          attributes: attributes.split(','),
          isSelectable: true,
          isRemovable: true,
          style: style,
          source: new _openlayers2.default.source.Vector({ wrapX: false, useSpatialIndex: false })
        });
        this.props.map.addLayer(layer);
        _FeatureStore2.default.addLayer(layer);
        this.close();
      }
    }
  }, {
    key: 'addLayers',
    value: function addLayers() {
      if (this.state.showCreate) {
        this._createLayer();
      } else if (this.state.showUpload) {
        this._readVectorFile();
      } else if (this.state.layer) {
        var layer = this._onLayerClick(this.state.layer);
        var extent = layer.get('EX_GeographicBoundingBox');
        if (extent) {
          var map = this.props.map;
          var view = map.getView();
          map.getView().fit(_openlayers2.default.proj.transformExtent(extent, 'EPSG:4326', view.getProjection()), map.getSize());
        }
        this.close();
      }
    }
  }, {
    key: '_handleRequestClose',
    value: function _handleRequestClose() {
      this.setState({
        errorOpen: false
      });
    }
  }, {
    key: '_onNewTypeChange',
    value: function _onNewTypeChange(evt, idx, value) {
      this.setState({ newType: value });
    }
  }, {
    key: '_onNewUrlBlur',
    value: function _onNewUrlBlur() {
      this.addServer();
    }
  }, {
    key: '_onNewUrlChange',
    value: function _onNewUrlChange(evt, value) {
      this.setState({ newUrl: value });
    }
  }, {
    key: '_onNewNameChange',
    value: function _onNewNameChange(evt, value) {
      this.setState({ newName: value });
    }
  }, {
    key: '_onSourceChange',
    value: function _onSourceChange(evt, idx, value) {
      if (value === createOption) {
        this.setState({ layerInfo: null, showNew: false, showUpload: false, showCreate: true, layer: null, source: value });
      } else if (value === uploadOption) {
        this.setState({ layerInfo: null, showNew: false, showUpload: true, showCreate: false, layer: null, source: value });
      } else if (value === newOption) {
        this.setState({ layerInfo: null, showUpload: false, showNew: true, showCreate: false, layer: null, source: value });
      } else {
        this.setState({ layerInfo: null, showUpload: false, showNew: false, showCreate: false, source: value }, function () {
          this._refreshService();
        }, this);
      }
    }
  }, {
    key: '_refreshService',
    value: function _refreshService(onFailure) {
      this._getCaps(onFailure);
    }
  }, {
    key: 'addServer',
    value: function addServer() {
      var name = this.state.newName;
      var url = this.state.newUrl;
      var serverType = this.state.newType;
      var sources = this.state.sources.slice();
      if (url.indexOf('http://') === -1 && url.indexOf('https://') === -1 && url[0] !== '/') {
        url = 'http://' + url;
      }
      sources.push({
        title: name,
        type: serverType,
        url: url
      });
      this.setState({ source: sources.length - 1, sources: sources }, function () {
        var me = this;
        this._refreshService(function () {
          var sources = me.state.sources.slice();
          sources.splice(-1, 1);
          me.setState({ sources: sources, source: sources.length - 1 }, function () {
            me._refreshService();
          });
        });
      }, this);
    }
  }, {
    key: '_onChangeSelectLayer',
    value: function _onChangeSelectLayer(evt, idx, value) {
      this.setState({
        layer: value
      });
    }
  }, {
    key: '_readFile',
    value: function _readFile(text) {
      this._text = text;
    }
  }, {
    key: '_generateId',
    value: function _generateId() {
      this._counter++;
      return ID_PREFIX + this._counter;
    }
  }, {
    key: '_readVectorFile',
    value: function _readVectorFile() {
      this.setState({
        loading: true
      });
      var me = this;
      var formatMessage = this.props.intl.formatMessage;

      global.setTimeout(function () {
        var text = me._text;
        var filename = me.state.fileName;
        if (text && filename) {
          var ext = filename.split('.').pop().toLowerCase();
          var format = AddLayerModal.formats[ext];
          var map = me.props.map;
          if (format) {
            try {
              var crs = format.readProjection(text);
              if (crs === undefined) {
                me.setState({ loading: false, error: true, fileName: '', errorOpen: true, msg: formatMessage(messages.uploadunsupportedprojection) });
                return;
              }
              var features = format.readFeatures(text, { dataProjection: crs,
                featureProjection: map.getView().getProjection() });
              if (features && features.length > 0) {
                var fill = me.state.hasFill ? new _openlayers2.default.style.Fill({ color: _util2.default.transformColor(me.state.fillColor) }) : undefined;
                var stroke = me.state.hasStroke ? new _openlayers2.default.style.Stroke({ color: _util2.default.transformColor(me.state.strokeColor), width: me.state.strokeWidth }) : undefined;
                var style = new _openlayers2.default.style.Style({
                  fill: fill,
                  stroke: stroke,
                  image: new _openlayers2.default.style.Circle({ stroke: stroke, fill: fill, radius: 7 })
                });
                me._counter++;
                var feature = features[0];
                var attributes = feature.getKeys();
                attributes.splice(attributes.indexOf(feature.getGeometryName()), 1);
                var geom = feature.getGeometry();
                var geomType;
                if (geom instanceof _openlayers2.default.geom.Polygon || geom instanceof _openlayers2.default.geom.MultiPolygon) {
                  geomType = 'Polygon';
                } else if (geom instanceof _openlayers2.default.geom.LineString || geom instanceof _openlayers2.default.geom.MultiLineString) {
                  geomType = 'Line';
                } else if (geom instanceof _openlayers2.default.geom.Point || geom instanceof _openlayers2.default.geom.MultiPoint) {
                  geomType = 'Point';
                }
                var lyr = new _openlayers2.default.layer.Vector({
                  id: me._generateId(),
                  attributes: attributes,
                  geometryType: geomType,
                  style: style,
                  source: new _openlayers2.default.source.Vector({
                    features: features,
                    wrapX: false
                  }),
                  title: filename,
                  isRemovable: true,
                  isSelectable: true
                });
                map.addLayer(lyr);
                _FeatureStore2.default.addLayer(lyr);
                var extent = lyr.getSource().getExtent();
                var valid = true;
                for (var i = 0, ii = extent.length; i < ii; ++i) {
                  var value = extent[i];
                  if (Math.abs(value) == Infinity || isNaN(value) || value < -20037508.342789244 || value > 20037508.342789244) {
                    valid = false;
                    break;
                  }
                }
                if (valid) {
                  map.getView().fit(extent, map.getSize());
                }
                me.close();
              }
            } catch (e) {
              me.setState({ loading: false, error: true, fileName: '', errorOpen: true, msg: e.message });
            }
          }
        }
      }, 0);
    }
  }, {
    key: '_onDrop',
    value: function _onDrop(files) {
      var formatMessage = this.props.intl.formatMessage;

      if (files.length === 1) {
        var r = new FileReader(),
            file = files[0];
        var me = this;
        var ext = file.name.split('.').pop().toLowerCase();
        var format = AddLayerModal.formats[ext];
        if (format) {
          this.setState({ fileName: file.name });
          r.onload = function (e) {
            me._readFile(e.target.result);
          };
          r.readAsText(file);
        } else {
          me.setState({ error: true, errorOpen: true, msg: formatMessage(messages.uploadunsupported) });
        }
      }
    }
  }, {
    key: '_onChangeFill',
    value: function _onChangeFill(state) {
      this.setState(state);
    }
  }, {
    key: '_onChangeStroke',
    value: function _onChangeStroke(state) {
      this.setState(state);
    }
  }, {
    key: '_changeGeometryType',
    value: function _changeGeometryType(evt, idx, value) {
      this.setState({
        geometryType: value
      });
    }
  }, {
    key: '_onChangeCreateTitle',
    value: function _onChangeCreateTitle(evt, value) {
      this.setState({
        createTitle: value
      });
    }
  }, {
    key: '_onChangeAttributes',
    value: function _onChangeAttributes(evt, value) {
      this.setState({
        attributes: value
      });
    }
  }, {
    key: 'render',
    value: function render() {
      var formatMessage = this.props.intl.formatMessage;

      var selectOptions = this.state.sources.map(function (source, idx) {
        return _react2.default.createElement(_MenuItem2.default, { key: idx, value: idx, primaryText: source.title });
      });
      var typeOptions = AddLayerModal.addNewTypes.map(function (newType) {
        return _react2.default.createElement(_MenuItem2.default, { key: newType, value: newType, primaryText: newType });
      });
      if (this.props.allowUpload) {
        selectOptions.push(_react2.default.createElement(_MenuItem2.default, { key: uploadOption, value: uploadOption, primaryText: formatMessage(messages.uploadoption) }));
      }
      if (this.props.allowCreate) {
        selectOptions.push(_react2.default.createElement(_MenuItem2.default, { key: createOption, value: createOption, primaryText: formatMessage(messages.createlayeroption) }));
      }
      if (this.props.allowUserInput) {
        selectOptions.push(_react2.default.createElement(_MenuItem2.default, { key: newOption, value: newOption, primaryText: formatMessage(messages.addserveroption) }));
      }
      var layers,
          layerMenuItems = [];
      if (this.state.layerInfo) {
        this._getLayersMarkup(this.state.layerInfo, layerMenuItems);
        layers = _react2.default.createElement(
          _SelectField2.default,
          { fullWidth: true, value: this.state.layer, onChange: this._onChangeSelectLayer.bind(this), floatingLabelText: formatMessage(messages.selectlayercombo) },
          layerMenuItems
        );
      }
      var loadingIndicator;
      if (this.state.loading === true) {
        loadingIndicator = _react2.default.createElement(_CircularProgress2.default, { size: 50, thickness: 3 });
      }
      var error;
      if (this.state.error === true) {
        error = _react2.default.createElement(_Snackbar2.default, {
          autoHideDuration: 5000,
          style: { transitionProperty: 'none' },
          bodyStyle: { lineHeight: '24px', height: 'auto' },
          open: this.state.errorOpen,
          message: formatMessage(messages.errormsg, { msg: this.state.msg }),
          onRequestClose: this._handleRequestClose.bind(this)
        });
      }
      var actions = [_react2.default.createElement(_Button2.default, { key: 'closeButton', buttonType: 'Flat', label: formatMessage(messages.closebutton), onTouchTap: this.close.bind(this) }), _react2.default.createElement(_Button2.default, { key: 'saveButton', buttonType: 'Flat', primary: true, label: formatMessage(messages.addbutton), onTouchTap: this.addLayers.bind(this) })];
      var create;
      if (this.state.showCreate) {
        create = _react2.default.createElement(
          'div',
          { className: 'noBorderPaper' },
          _react2.default.createElement(_TextField2.default, {
            value: this.state.createTitle,
            floatingLabelFixed: true,
            onChange: this._onChangeCreateTitle.bind(this),
            hintText: formatMessage(messages.createtitlehinttext),
            floatingLabelText: formatMessage(messages.createtitlelabeltext),
            fullWidth: true
          }),
          _react2.default.createElement(
            _SelectField2.default,
            { fullWidth: true, value: this.state.geometryType, onChange: this._changeGeometryType.bind(this), floatingLabelText: formatMessage(messages.geometrytypelabel) },
            _react2.default.createElement(_MenuItem2.default, { key: 'Point', value: 'Point', primaryText: formatMessage(messages.pointgeomtype) }),
            _react2.default.createElement(_MenuItem2.default, { key: 'LineString', value: 'LineString', primaryText: formatMessage(messages.linegeomtype) }),
            _react2.default.createElement(_MenuItem2.default, { key: 'Polygon', value: 'Polygon', primaryText: formatMessage(messages.polygeomtype) })
          ),
          _react2.default.createElement(_TextField2.default, { fullWidth: true, floatingLabelFixed: true, value: this.state.attributes, hintText: formatMessage(messages.attributeshint), floatingLabelText: formatMessage(messages.attributeslabel), onChange: this._onChangeAttributes.bind(this) }),
          _react2.default.createElement(_FillEditor2.default, { disabled: true, onChange: this._onChangeFill.bind(this), intl: this.props.intl }),
          _react2.default.createElement(_StrokeEditor2.default, { disabled: true, onChange: this._onChangeStroke.bind(this), intl: this.props.intl })
        );
      }
      var upload;
      if (this.state.showUpload) {
        upload = _react2.default.createElement(
          'div',
          null,
          _react2.default.createElement(
            'div',
            { className: 'addLayer-fileField' },
            _react2.default.createElement(
              _reactDropzone2.default,
              { accept: '.json,.geojson,.kml,.gpx', className: 'dropzone', multiple: false, onDrop: this._onDrop.bind(this) },
              _react2.default.createElement(_TextField2.default, {
                value: this.state.fileName,
                floatingLabelFixed: true,
                hintText: formatMessage(messages.uploadhinttext),
                floatingLabelText: formatMessage(messages.uploadlabeltext),
                fullWidth: true
              }),
              _react2.default.createElement(
                _IconButton2.default,
                { tooltip: formatMessage(messages.uploadicontooltip), tooltipPosition: 'top-left', className: 'icon' },
                _react2.default.createElement(_FontIcon2.default, { className: 'ms ms-directory' })
              )
            )
          ),
          _react2.default.createElement(_FillEditor2.default, { className: 'addLayer-colorPicker', disabled: true, onChange: this._onChangeFill.bind(this), intl: this.props.intl }),
          _react2.default.createElement(_StrokeEditor2.default, { disabled: true, onChange: this._onChangeStroke.bind(this), intl: this.props.intl })
        );
      }
      var newDialog;
      if (this.state.showNew) {
        newDialog = _react2.default.createElement(
          'div',
          null,
          _react2.default.createElement(
            _SelectField2.default,
            { fullWidth: true, floatingLabelText: formatMessage(messages.servertypelabel), value: this.state.newType, onChange: this._onNewTypeChange.bind(this) },
            typeOptions
          ),
          _react2.default.createElement(_TextField2.default, { floatingLabelFixed: true, hintText: formatMessage(messages.newservernamehint), value: this.state.newName, onChange: this._onNewNameChange.bind(this), fullWidth: true, floatingLabelText: formatMessage(messages.newservername) }),
          _react2.default.createElement(_TextField2.default, { floatingLabelFixed: true, hintText: formatMessage(messages.newserverurlhint), value: this.state.newUrl, onBlur: this._onNewUrlBlur.bind(this), onChange: this._onNewUrlChange.bind(this), fullWidth: true, floatingLabelText: formatMessage(messages.newserverurl) })
        );
      }
      var content = _react2.default.createElement(
        'div',
        null,
        newDialog,
        upload,
        create,
        layers,
        loadingIndicator,
        error
      );
      var select = _react2.default.createElement(
        _SelectField2.default,
        { fullWidth: true, floatingLabelText: formatMessage(messages.sourcecombo), value: this.state.source, onChange: this._onSourceChange.bind(this) },
        selectOptions
      );
      return _react2.default.createElement(
        _Dialog2.default,
        { ref: 'dialog', style: this.props.style, autoScrollBodyContent: true, bodyStyle: { padding: 20 }, inline: this.props.inline, title: formatMessage(messages.title), className: 'add-layer-modal', actions: actions, open: this.props.open, onRequestClose: this.close.bind(this) },
        select,
        content
      );
    }
  }]);

  return AddLayerModal;
}(_react2.default.PureComponent), _class.propTypes = {
  /**
   * The ol3 map to add layers to.
   */
  map: _react2.default.PropTypes.instanceOf(_openlayers2.default.Map).isRequired,
  /**
   * Css class name to apply on the dialog.
   */
  className: _react2.default.PropTypes.string,
  /**
   * List of sources to use for this dialog. Entries have a title, type and url property. Type can be one of: WMS, WFS, WMTS or ArcGISRest.
   */
  sources: _react2.default.PropTypes.arrayOf(_react2.default.PropTypes.shape({
    title: _react2.default.PropTypes.string.isRequired,
    type: _react2.default.PropTypes.string.isRequired,
    url: _react2.default.PropTypes.string.isRequired
  })),
  /**
   * If true users can Input new layers
   */
  allowUserInput: _react2.default.PropTypes.bool,
  /**
  *  Callback for closing the modal
  */
  onRequestClose: _react2.default.PropTypes.func,
  /**
  *  Controls opening the modal
  */
  open: _react2.default.PropTypes.bool.isRequired,
  /**
   * Should we allow people to upload their local vector files?
   */
  allowUpload: _react2.default.PropTypes.bool,
  /**
   * Should we allow people to create new vector layers?
   */
  allowCreate: _react2.default.PropTypes.bool,
  /**
   * Style config
   */
  style: _react2.default.PropTypes.object,
  /**
   * @ignore
   */
  intl: _reactIntl.intlShape.isRequired
}, _class.contextTypes = {
  muiTheme: _react2.default.PropTypes.object,
  proxy: _react2.default.PropTypes.string,
  requestHeaders: _react2.default.PropTypes.object
}, _class.childContextTypes = {
  muiTheme: _react2.default.PropTypes.object.isRequired
}, _class.defaultProps = {
  allowUserInput: false,
  allowUpload: true,
  open: false,
  allowCreate: true
}, _class.formats = {
  'geojson': new _openlayers2.default.format.GeoJSON(),
  'json': new _openlayers2.default.format.GeoJSON(),
  'kml': new _openlayers2.default.format.KML({ extractStyles: false }),
  'gpx': new _openlayers2.default.format.GPX()
}, _class.addNewTypes = ['WMS', 'WFS', 'ArcGISRest', 'WMTS'], _class.services = {
  'WMS': _WMSService2.default,
  'WFS': _WFSService2.default,
  'ArcGISRest': _ArcGISRestService2.default,
  'WMTS': _WMTSService2.default
}, _temp);
exports.default = (0, _reactIntl.injectIntl)(AddLayerModal);