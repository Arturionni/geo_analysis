'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Copyright 2015-present Boundless Spatial Inc., http://boundlessgeo.com
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Licensed under the Apache License, Version 2.0 (the "License").
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * You may not use this file except in compliance with the License.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * You may obtain a copy of the License at
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * http://www.apache.org/licenses/LICENSE-2.0
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Unless required by applicable law or agreed to in writing, software
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * distributed under the License is distributed on an "AS IS" BASIS,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * See the License for the specific language governing permissions and limitations under the License.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */

var _util = require('../util');

var _util2 = _interopRequireDefault(_util);

var _urlParse = require('url-parse');

var _urlParse2 = _interopRequireDefault(_urlParse);

var _openlayers = require('openlayers');

var _openlayers2 = _interopRequireDefault(_openlayers);

var _SLDService = require('./SLDService');

var _SLDService2 = _interopRequireDefault(_SLDService);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var wmsCapsFormat = new _openlayers2.default.format.WMSCapabilities();
var wmsGetFeatureInfoFormats = {
  'application/json': new _openlayers2.default.format.GeoJSON(),
  'application/vnd.ogc.gml': new _openlayers2.default.format.WMSGetFeatureInfo()
};

var WMSService = function () {
  function WMSService() {
    _classCallCheck(this, WMSService);
  }

  _createClass(WMSService, [{
    key: 'getCapabilitiesUrl',
    value: function getCapabilitiesUrl(url, opt_proxy) {
      var urlObj = new _urlParse2.default(url, true);
      urlObj.set('query', Object.assign(urlObj.query, {
        service: 'WMS',
        request: 'GetCapabilities',
        version: '1.3.0'
      }));
      return _util2.default.getProxiedUrl(urlObj.toString(), opt_proxy);
    }
  }, {
    key: '_getGetMapUrl',
    value: function _getGetMapUrl(info) {
      var dcp = info.Capability.Request.GetMap.DCPType;
      for (var i = 0, ii = dcp.length; i < ii; ++i) {
        if (dcp[i].HTTP && dcp[i].HTTP.Get) {
          return dcp[i].HTTP.Get.OnlineResource;
        }
      }
    }
  }, {
    key: 'getCapabilities',
    value: function getCapabilities(url, onSuccess, onFailure, opt_proxy, opt_requestHeaders) {
      return _util2.default.doGET(this.getCapabilitiesUrl(url, opt_proxy), function (xmlhttp) {
        var info = wmsCapsFormat.read(xmlhttp.responseText);
        onSuccess.call(this, info.Capability.Layer, this._getGetMapUrl(info));
      }, function (xmlhttp) {
        onFailure.call(this, xmlhttp);
      }, this, opt_requestHeaders);
    }
  }, {
    key: 'createLayerFromGetCaps',
    value: function createLayerFromGetCaps(url, layerName, projection, callback, opt_proxy) {
      this.getCapabilities(url, function (layerInfo, getMapUrl) {
        for (var i = 0, ii = layerInfo.Layer.length; i < ii; ++i) {
          if (layerInfo.Layer[i].Name === layerName) {
            return callback.call(this, this.createLayer(layerInfo.Layer[i], getMapUrl || url, { title: layerInfo.Layer[i].Title }, projection, opt_proxy));
          }
        }
      }, function () {}, opt_proxy);
    }
  }, {
    key: 'createLayer',
    value: function createLayer(layer, url, titleObj, projection, opt_proxy) {
      var getLegendUrl = function getLegendUrl(layer) {
        if (layer.Style && layer.Style.length === 1) {
          if (layer.Style[0].LegendURL && layer.Style[0].LegendURL.length >= 1) {
            return layer.Style[0].LegendURL[0].OnlineResource;
          }
        }
      };
      var units = projection.getUnits();
      var source = new _openlayers2.default.source.TileWMS({
        url: url,
        wrapX: layer.Layer ? true : false,
        crossOrigin: 'anonymous',
        params: {
          LAYERS: layer.Name,
          TILED: true
        }
      });
      if (opt_proxy) {
        source.once('tileloaderror', function () {
          source.setTileLoadFunction(function () {
            var tileLoadFn = source.getTileLoadFunction();
            return function (tile, src) {
              tileLoadFn(tile, _util2.default.getProxiedUrl(src, opt_proxy));
            };
          }());
        });
      }
      return new _openlayers2.default.layer.Tile({
        title: titleObj.title,
        emptyTitle: titleObj.empty,
        id: layer.Name,
        name: layer.Name,
        legendUrl: getLegendUrl(layer),
        minResolution: layer.MinScaleDenominator > 0 ? _util2.default.getResolutionForScale(layer.MinScaleDenominator, units) : undefined,
        maxResolution: layer.MaxScaleDenominator > 0 ? _util2.default.getResolutionForScale(layer.MaxScaleDenominator, units) : undefined,
        isRemovable: true,
        isSelectable: true,
        isWFST: true,
        timeInfo: _util2.default.getTimeInfo(layer),
        type: layer.Layer ? 'base' : undefined,
        EX_GeographicBoundingBox: layer.EX_GeographicBoundingBox,
        popupInfo: '#AllAttributes',
        source: source
      });
    }
  }, {
    key: 'getStylesUrl',
    value: function getStylesUrl(url, layer, opt_proxy) {
      var urlObj = new _urlParse2.default(url);
      urlObj.set('query', {
        service: 'WMS',
        request: 'GetStyles',
        layers: layer.get('name'),
        version: '1.1.1'
      });
      return _util2.default.getProxiedUrl(urlObj.toString(), opt_proxy);
    }
  }, {
    key: 'getStyles',
    value: function getStyles(url, layer, onSuccess, onFailure, opt_proxy, opt_requestHeaders) {
      return _util2.default.doGET(this.getStylesUrl(url, layer, opt_proxy), function (xmlhttp) {
        var info = _SLDService2.default.parse(xmlhttp.responseText);
        onSuccess.call(this, info);
      }, function (xmlhttp) {
        onFailure.call(this, xmlhttp);
      }, this, opt_requestHeaders);
    }
  }, {
    key: 'getFeatureInfoUrl',
    value: function getFeatureInfoUrl(layer, coordinate, view, infoFormat, opt_proxy) {
      var resolution = view.getResolution(),
          projection = view.getProjection();
      var url = layer.getSource().getGetFeatureInfoUrl(coordinate, resolution, projection, {
        'INFO_FORMAT': infoFormat
      });
      return _util2.default.getProxiedUrl(url, opt_proxy);
    }
  }, {
    key: 'getFeatureInfo',
    value: function getFeatureInfo(layer, coordinate, map, infoFormat, onSuccess, onFailure, opt_proxy, opt_requestHeaders) {
      var view = map.getView();
      _util2.default.doGET(this.getFeatureInfoUrl(layer, coordinate, view, infoFormat, opt_proxy), function (response) {
        var result = {};
        if (infoFormat === 'text/plain' || infoFormat === 'text/html') {
          if (response.responseText.trim() !== 'no features were found') {
            result.text = response.responseText;
          } else {
            result = false;
          }
        } else {
          result.features = wmsGetFeatureInfoFormats[infoFormat].readFeatures(response.responseText);
        }
        result.layer = layer;
        onSuccess.call(this, result);
      }, onFailure, this, opt_requestHeaders);
    }
  }]);

  return WMSService;
}();

exports.default = new WMSService();