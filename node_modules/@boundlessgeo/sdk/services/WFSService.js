'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Copyright 2015-present Boundless Spatial Inc., http://boundlessgeo.com
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Licensed under the Apache License, Version 2.0 (the "License").
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * You may not use this file except in compliance with the License.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * You may obtain a copy of the License at
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * http://www.apache.org/licenses/LICENSE-2.0
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Unless required by applicable law or agreed to in writing, software
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * distributed under the License is distributed on an "AS IS" BASIS,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * See the License for the specific language governing permissions and limitations under the License.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */

var _openlayers = require('openlayers');

var _openlayers2 = _interopRequireDefault(_openlayers);

var _util = require('../util');

var _util2 = _interopRequireDefault(_util);

var _jsonix = require('@boundlessgeo/jsonix');

var _urlParse = require('url-parse');

var _urlParse2 = _interopRequireDefault(_urlParse);

var _XSD_1_ = require('w3c-schemas/lib/XSD_1_0');

var _XLink_1_ = require('w3c-schemas/lib/XLink_1_0');

var _OWS_1_0_ = require('ogc-schemas/lib/OWS_1_0_0');

var _Filter_1_1_ = require('ogc-schemas/lib/Filter_1_1_0');

var _SMIL_2_ = require('ogc-schemas/lib/SMIL_2_0');

var _SMIL_2_0_Language = require('ogc-schemas/lib/SMIL_2_0_Language');

var _GML_3_1_ = require('ogc-schemas/lib/GML_3_1_1');

var _WFS_1_1_ = require('ogc-schemas/lib/WFS_1_1_0');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var wfsFormat = new _openlayers2.default.format.WFS();
var geojsonFormat = new _openlayers2.default.format.GeoJSON();
var xmlSerializer = new XMLSerializer();
var wfsContext = new _jsonix.Jsonix.Context([_OWS_1_0_.OWS_1_0_0, _Filter_1_1_.Filter_1_1_0, _SMIL_2_.SMIL_2_0, _SMIL_2_0_Language.SMIL_2_0_Language, _XLink_1_.XLink_1_0, _GML_3_1_.GML_3_1_1, _WFS_1_1_.WFS_1_1_0]);
var wfsUnmarshaller = wfsContext.createUnmarshaller();
var xsdContext = new _jsonix.Jsonix.Context([_XSD_1_.XSD_1_0]);
var xsdUnmarshaller = xsdContext.createUnmarshaller();

var defaultFeaturePrefix = 'feature';

var proj4326 = new _openlayers2.default.proj.Projection({
  code: 'http://www.opengis.net/gml/srs/epsg.xml#4326',
  axis: 'enu'
});
_openlayers2.default.proj.addEquivalentProjections([_openlayers2.default.proj.get('EPSG:4326'), proj4326]);

var WFSService = function () {
  function WFSService() {
    _classCallCheck(this, WFSService);
  }

  _createClass(WFSService, [{
    key: 'createSource',
    value: function createSource(_url, projection, typeName, opt_proxy) {
      return new _openlayers2.default.source.Vector({
        wrapX: false,
        url: function url(extent) {
          var urlObj = new _urlParse2.default(_url);
          urlObj.set('query', {
            service: 'WFS',
            request: 'GetFeature',
            version: '1.1.0',
            typename: typeName,
            outputFormat: 'application/json',
            srsname: projection.getCode(),
            bbox: extent.join(',') + ',' + projection.getCode()
          });
          return _util2.default.getProxiedUrl(urlObj.toString(), opt_proxy);
        },
        format: geojsonFormat,
        strategy: _openlayers2.default.loadingstrategy.bbox
      });
    }
  }, {
    key: 'createLayer',
    value: function createLayer(layer, url, titleObj, projection, opt_proxy) {
      return new _openlayers2.default.layer.Vector({
        title: titleObj.title,
        emptyTitle: titleObj.empty,
        id: layer.Name,
        name: layer.Name,
        isWFST: true,
        timeInfo: _util2.default.getTimeInfo(layer),
        isRemovable: true,
        isSelectable: true,
        popupInfo: '#AllAttributes',
        url: url,
        source: this.createSource(url, projection, layer.Name, opt_proxy)
      });
    }
  }, {
    key: 'parseCapabilities',
    value: function parseCapabilities(xmlhttp) {
      var layers = [];
      var info = wfsUnmarshaller.unmarshalDocument(xmlhttp.responseXML).value;
      if (info && info.featureTypeList && info.featureTypeList.featureType) {
        for (var i = 0, ii = info.featureTypeList.featureType.length; i < ii; ++i) {
          var ft = info.featureTypeList.featureType[i];
          var layer = {};
          layer.Name = ft.name.prefix + ':' + ft.name.localPart;
          if (ft.keywords) {
            layer.KeywordList = ft.keywords[0].keyword;
          }
          layer.Title = ft.title;
          layer.Abstract = ft._abstract;
          layer.EX_GeographicBoundingBox = [ft.wgs84BoundingBox[0].lowerCorner[0], ft.wgs84BoundingBox[0].lowerCorner[1], ft.wgs84BoundingBox[0].upperCorner[0], ft.wgs84BoundingBox[0].upperCorner[1]];
          layers.push(layer);
        }
      }
      return {
        layers: layers,
        title: info.serviceIdentification.title
      };
    }
  }, {
    key: 'getCapabilitiesUrl',
    value: function getCapabilitiesUrl(url, opt_proxy) {
      var urlObj = new _urlParse2.default(url);
      urlObj.set('query', {
        service: 'WFS',
        version: '1.1.0',
        request: 'GetCapabilities'
      });
      return _util2.default.getProxiedUrl(urlObj.toString(), opt_proxy);
    }
  }, {
    key: 'getCapabilities',
    value: function getCapabilities(url, onSuccess, onFailure, opt_proxy, opt_requestHeaders) {
      return _util2.default.doGET(this.getCapabilitiesUrl(url, opt_proxy), function (xmlhttp) {
        var info = this.parseCapabilities(xmlhttp);
        onSuccess.call(this, { Title: info.title, Layer: info.layers });
      }, function (xmlhttp) {
        onFailure.call(this, xmlhttp);
      }, this, opt_requestHeaders);
    }
  }, {
    key: 'describeFeatureType',
    value: function describeFeatureType(url, layerName, onSuccess, onFailure, scope, opt_proxy, opt_requestHeaders) {
      var dftUrl = new _urlParse2.default(url);
      dftUrl.set('query', {
        service: 'WFS',
        request: 'DescribeFeatureType',
        version: '1.0.0',
        typename: layerName
      });
      _util2.default.doGET(_util2.default.getProxiedUrl(dftUrl.toString(), opt_proxy), function (xmlhttp) {
        if (xmlhttp.responseText.indexOf('<?xml') !== -1 && xmlhttp.responseText.indexOf('ServiceExceptionReport') === -1) {
          var schema = xsdUnmarshaller.unmarshalString(xmlhttp.responseText).value;
          var element = schema.complexType[0].complexContent.extension.sequence.element;
          var geometryType, geometryName;
          var attributes = [];
          for (var i = 0, ii = element.length; i < ii; ++i) {
            var el = element[i];
            if (el.type.namespaceURI === 'http://www.opengis.net/gml') {
              geometryName = el.name;
              var lp = el.type.localPart;
              geometryType = lp.replace('PropertyType', '');
            } else if (el.name !== 'boundedBy') {
              // TODO if needed, use attribute type as well
              attributes.push(el.name);
            }
          }
          attributes.sort(function (a, b) {
            return a.toLowerCase().localeCompare(b.toLowerCase());
          });
          onSuccess.call(scope || this, {
            featureNS: schema.targetNamespace,
            featurePrefix: layerName.split(':').shift(),
            featureType: schema.element[0].name,
            geometryType: geometryType,
            geometryName: geometryName,
            attributes: attributes,
            url: url
          });
        } else {
          onFailure.call(scope || this, xmlhttp);
        }
      }, function (xmlhttp) {
        onFailure.call(scope || this, xmlhttp);
      }, this, opt_requestHeaders);
    }
  }, {
    key: 'loadFeatures',
    value: function loadFeatures(layer, startIndex, maxFeatures, sortingInfo, srsName, onSuccess, onFailure, opt_proxy, opt_requestHeaders) {
      var wfsInfo = layer.get('wfsInfo');
      var url = wfsInfo.url;
      var urlObj = new _urlParse2.default(url);
      var params = {
        service: 'WFS',
        request: 'GetFeature',
        startIndex: startIndex,
        maxFeatures: maxFeatures,
        version: '1.1.0',
        typename: wfsInfo.featureType,
        srsname: 'EPSG:4326'
      };
      if (sortingInfo.length === 1) {
        params.sortBy = sortingInfo[0].id + ' ' + (sortingInfo[0].asc ? 'A' : 'D');
      }
      urlObj.set('query', params);
      _util2.default.doGET(_util2.default.getProxiedUrl(urlObj.toString(), opt_proxy), function (xmlhttp) {
        var data = xmlhttp.responseXML;
        if (data !== null) {
          this.readResponse(data, xmlhttp, function (data) {
            var features = wfsFormat.readFeatures(data, { dataProjection: proj4326, featureProjection: srsName });
            onSuccess.call(this, features);
          }, onFailure);
        } else {
          onFailure.call(this, xmlhttp);
        }
      }, function (xmlhttp) {
        onFailure.call(this, xmlhttp);
      }, this, opt_requestHeaders);
    }
  }, {
    key: 'getNumberOfFeatures',
    value: function getNumberOfFeatures(layer, callback, opt_proxy, opt_requestHeaders) {
      if (layer.get('numberOfFeatures') === undefined) {
        var wfsInfo = layer.get('wfsInfo');
        var url = wfsInfo.url;
        var urlObj = new _urlParse2.default(url);
        urlObj.set('query', {
          service: 'WFS',
          request: 'GetFeature',
          resultType: 'hits',
          version: '1.1.0',
          typename: wfsInfo.featureType
        });
        _util2.default.doGET(_util2.default.getProxiedUrl(urlObj.toString(), opt_proxy), function (xmlhttp) {
          var info = wfsFormat.readFeatureCollectionMetadata(xmlhttp.responseXML);
          callback.call(this, info.numberOfFeatures);
        }, undefined, opt_requestHeaders);
      }
    }
  }, {
    key: 'bboxFilter',
    value: function bboxFilter(layer, view, extent, onSuccess, onFailure, opt_proxy, opt_requestHeaders) {
      var wfsInfo = layer.get('wfsInfo');
      var url = new _urlParse2.default(wfsInfo.url);
      var srs = view.getProjection().getCode();
      url.set('query', {
        service: 'WFS',
        request: 'GetFeature',
        version: '1.1.0',
        srsName: srs,
        typename: wfsInfo.featureType,
        bbox: extent.join(',') + ',' + srs
      });
      return _util2.default.doGET(_util2.default.getProxiedUrl(url.toString(), opt_proxy), function (xmlhttp) {
        var features = wfsFormat.readFeatures(xmlhttp.responseXML);
        onSuccess.call(this, features);
      }, onFailure, this, opt_requestHeaders);
    }
  }, {
    key: 'generateDistanceWithinUrl',
    value: function generateDistanceWithinUrl(layer, view, coord) {
      var point = _openlayers2.default.proj.toLonLat(coord);
      var wfsInfo = layer.get('wfsInfo');
      var url = new _urlParse2.default(wfsInfo.url);
      url.set('query', {
        service: 'WFS',
        request: 'GetFeature',
        version: '1.1.0',
        srsName: view.getProjection().getCode(),
        typename: wfsInfo.featureType,
        cql_filter: 'DWITHIN(' + wfsInfo.geometryName + ', Point(' + point[1] + ' ' + point[0] + '), 0.1, meters)'
      });
      return url.toString();
    }
  }, {
    key: 'distanceWithin',
    value: function distanceWithin(layer, view, coord, onSuccess, onFailure, opt_proxy, opt_requestHeaders) {
      return _util2.default.doGET(_util2.default.getProxiedUrl(this.generateDistanceWithinUrl(layer, view, coord), opt_proxy), function (xmlhttp) {
        var features = wfsFormat.readFeatures(xmlhttp.responseXML);
        if (features.length > 0) {
          onSuccess.call(this, features[0]);
        } else if (onFailure) {
          onFailure.call(this, xmlhttp);
        }
      }, onFailure, this, opt_requestHeaders);
    }
  }, {
    key: 'readResponse',
    value: function readResponse(data, xmlhttp, onSuccess, onFailure) {
      if (global.Document && data instanceof global.Document && data.documentElement && data.documentElement.localName == 'ExceptionReport') {
        if (onFailure) {
          onFailure.call(this, xmlhttp, data.getElementsByTagNameNS('http://www.opengis.net/ows', 'ExceptionText').item(0).textContent);
        }
      } else {
        onSuccess(data);
      }
    }
  }, {
    key: 'getDeletePayload',
    value: function getDeletePayload(wfsInfo, feature) {
      var node = wfsFormat.writeTransaction(null, null, [feature], {
        featureNS: wfsInfo.featureNS,
        featurePrefix: defaultFeaturePrefix,
        featureType: wfsInfo.featureType
      });
      return xmlSerializer.serializeToString(node);
    }
  }, {
    key: 'deleteFeature',
    value: function deleteFeature(layer, feature, onSuccess, onFailure) {
      var wfsInfo = layer.get('wfsInfo');
      return _util2.default.doPOST(wfsInfo.url, this.getDeletePayload(wfsInfo, feature), function (xmlhttp) {
        this.handleDeleteResponse(xmlhttp, onSuccess, onFailure);
      }, onFailure, this);
    }
  }, {
    key: 'handleDeleteResponse',
    value: function handleDeleteResponse(xmlhttp, onSuccess, onFailure) {
      var data = xmlhttp.responseXML;
      this.readResponse(data, xmlhttp, function (data) {
        var result = wfsFormat.readTransactionResponse(data);
        if (result && result.transactionSummary.totalDeleted === 1) {
          onSuccess.call(this);
        } else {
          onFailure.call(this, xmlhttp);
        }
      }, onFailure);
    }
  }, {
    key: 'getUpdatePayload',
    value: function getUpdatePayload(wfsInfo, view, feature, values) {
      var fid = feature.getId();
      var clone;
      var featureGeometryName = feature.getGeometryName();
      if (values !== null) {
        clone = new _openlayers2.default.Feature(values);
      } else {
        var properties = feature.getProperties();
        // get rid of boundedBy which is not a real property
        // get rid of bbox (in the case of GeoJSON)
        delete properties.boundedBy;
        delete properties.bbox;
        if (wfsInfo.geometryName !== featureGeometryName) {
          properties[wfsInfo.geometryName] = properties[featureGeometryName];
          delete properties[featureGeometryName];
        }
        clone = new _openlayers2.default.Feature(properties);
      }
      clone.setId(fid);
      if (view !== null && wfsInfo.geometryName !== featureGeometryName) {
        clone.setGeometryName(wfsInfo.geometryName);
      }
      var node = wfsFormat.writeTransaction(null, [clone], null, {
        gmlOptions: view !== null ? {
          srsName: view.getProjection().getCode()
        } : undefined,
        featureNS: wfsInfo.featureNS,
        featurePrefix: defaultFeaturePrefix,
        featureType: wfsInfo.featureType
      });
      return xmlSerializer.serializeToString(node);
    }
  }, {
    key: 'handleUpdateResponse',
    value: function handleUpdateResponse(xmlhttp, onSuccess, onFailure) {
      var data = xmlhttp.responseXML;
      this.readResponse(data, xmlhttp, function (data) {
        var result = wfsFormat.readTransactionResponse(data);
        if (result) {
          onSuccess.call(this, result);
        } else {
          onFailure.call(this, xmlhttp);
        }
      }, onFailure);
    }
  }, {
    key: 'updateFeature',
    value: function updateFeature(layer, view, feature, values, onSuccess, onFailure, opt_proxy, opt_requestHeaders) {
      var wfsInfo = layer.get('wfsInfo');
      return _util2.default.doPOST(_util2.default.getProxiedUrl(wfsInfo.url, opt_proxy), this.getUpdatePayload(wfsInfo, view, feature, values), function (xmlhttp) {
        this.handleUpdateResponse(xmlhttp, onSuccess, onFailure);
      }, onFailure, this, undefined, false, opt_requestHeaders);
    }
  }, {
    key: 'getInsertPayload',
    value: function getInsertPayload(wfsInfo, view, feature) {
      var node = wfsFormat.writeTransaction([feature], null, null, {
        gmlOptions: {
          srsName: view.getProjection().getCode()
        },
        featureNS: wfsInfo.featureNS,
        featurePrefix: defaultFeaturePrefix,
        featureType: wfsInfo.featureType
      });
      return xmlSerializer.serializeToString(node);
    }
  }, {
    key: 'handleInsertResponse',
    value: function handleInsertResponse(xmlhttp, onSuccess, onFailure) {
      var data = xmlhttp.responseXML;
      this.readResponse(data, xmlhttp, function (data) {
        var result = wfsFormat.readTransactionResponse(data);
        if (result) {
          var insertId = result.insertIds[0];
          onSuccess.call(this, insertId);
        } else {
          onFailure.call(this, xmlhttp);
        }
      }, onFailure);
    }
  }, {
    key: 'insertFeature',
    value: function insertFeature(layer, view, feature, onSuccess, onFailure, opt_proxy, opt_requestHeaders) {
      var wfsInfo = layer.get('wfsInfo');
      return _util2.default.doPOST(_util2.default.getProxiedUrl(wfsInfo.url, opt_proxy), this.getInsertPayload(wfsInfo, view, feature), function (xmlhttp) {
        this.handleInsertResponse(xmlhttp, onSuccess, onFailure);
      }, onFailure, this, undefined, false, opt_requestHeaders);
    }
  }]);

  return WFSService;
}();

exports.default = new WFSService();